<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Esta etiqueta es vital para que se vea bien en m칩viles -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <!-- 칈cono de pesta침a -->
    <link rel="icon" type="image/png" href="assets/icon.png">
    


    <title>游꾻Happy Christmas游꾻</title>
    <link href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Mountains of Christmas', cursive;
            touch-action: none;
        }
        canvas { display: block; }

        /* --- T칈TULO NE칍N ROJO --- */
        #main-title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            /* N칰cleo casi blanco para simular la intensidad de la luz */
            color: #fff5f5; 
            font-size: clamp(3rem, 12vw, 5rem); 
            margin-top: 15px;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.5s ease;
            /* Efecto Ne칩n multicapa */
            text-shadow: 
                0 0 5px #ff0000,
                0 0 10px #ff0000,
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 80px #ff0000;
        }

        /* --- PANTALLA DE INICIO --- */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
            transition: opacity 0.5s ease-out;
        }

        .emoji-container {
            font-size: 5rem;
            animation: pulse 1.5s infinite;
            margin-bottom: 20px;
        }

        .start-text {
            color: #FFD700;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #FFD700;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .fade-out { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <audio id="bg-music" loop>
        <source src="https://www.dl.dropboxusercontent.com/scl/fi/hfwf3xqcsmruqg9xjm5qs/3D-TREE-MAIN-SOUND.mp3?rlkey=ov72le8nzsdtvu49ff8p1a198&st=kkf26vjm" type="audio/mp3">
    </audio>

    <div id="start-overlay">
        <div class="emoji-container">游꾻</div>
        <div class="start-text">Click para iniciar</div>
    </div>

    <h1 id="main-title">Happy Christmas</h1>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- INTERFAZ ---
        const overlay = document.getElementById('start-overlay');
        const title = document.getElementById('main-title');
        const music = document.getElementById('bg-music');

        overlay.addEventListener('click', () => {
            music.volume = 0.5;
            music.play().catch(e => console.log(e));
            overlay.classList.add('fade-out');
            title.style.opacity = 1;
            setTimeout(() => { overlay.style.display = 'none'; }, 500);
        });

        // --- TEXTURA ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createParticleTexture();

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = false;
        document.body.appendChild(renderer.domElement);

        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // CONFIGURACI칍N DE NIVELES
        const levelsData = [
            { radius: 3.2, height: 3.5, y: -1.5, particleCount: 7000 }, 
            { radius: 2.5, height: 3.5, y: 0.5,  particleCount: 6000 }, 
            { radius: 1.6, height: 3.5, y: 2.5,  particleCount: 4000 }, 
            { radius: 0.6, height: 2.8, y: 4.8,  particleCount: 2000 }  
        ];

        // --- 1. ESTRUCTURA OSCURA ---
        const treeMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x051a0a, 
            shininess: 0,    
            map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg'),
        });
        treeMaterial.color.setHex(0x020a02);

        levelsData.forEach(level => {
            const geometry = new THREE.ConeGeometry(level.radius, level.height, 64);
            const pos = geometry.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                if (pos.getY(i) < level.height/2 - 0.5) {
                    pos.setX(i, pos.getX(i) + (Math.random() - 0.5) * 0.2);
                    pos.setZ(i, pos.getZ(i) + (Math.random() - 0.5) * 0.2);
                }
            }
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, treeMaterial);
            mesh.position.y = level.y;
            treeGroup.add(mesh);
        });

        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.6, 1.5, 32),
            new THREE.MeshStandardMaterial({ color: 0x0f0605, roughness: 0.9 })
        );
        trunk.position.y = -3.5;
        treeGroup.add(trunk);

        // --- 2. ADORNOS ---
        const ornamentGeometry = new THREE.SphereGeometry(0.18, 16, 16);
        const commonMat = { shininess: 50, emissiveIntensity: 0.8 }; 
        const ornamentMaterials = [
            new THREE.MeshPhongMaterial({ ...commonMat, color: 0xff0000, emissive: 0xff0000 }),
            new THREE.MeshPhongMaterial({ ...commonMat, color: 0x00ffff, emissive: 0x00ffff }),
            new THREE.MeshPhongMaterial({ ...commonMat, color: 0xffffff, emissive: 0xaaaaaa }),
            new THREE.MeshPhongMaterial({ ...commonMat, color: 0xFF1493, emissive: 0xFF1493 })
        ];

        function createOrnaments() {
            const levels = 9; 
            const levelPatterns = [
                ['white', 'red', 'blue', 'pink'], ['red', 'blue', 'white', 'pink', 'red'],
                ['blue', 'pink', 'red', 'white', 'blue', 'pink'], ['pink', 'white', 'blue', 'red', 'pink', 'white'],
                ['red', 'blue', 'pink', 'white', 'red', 'blue', 'pink'], ['blue', 'pink', 'white', 'red', 'blue', 'pink', 'white'],
                ['pink', 'red', 'blue', 'white', 'pink', 'red', 'blue'], ['white', 'pink', 'red', 'blue', 'white', 'pink', 'red', 'blue'],
                ['red', 'blue', 'pink', 'white', 'red', 'blue', 'pink', 'white', 'red'] 
            ];
            for(let level = 0; level < levels; level++) {
                const t = level / (levels - 1);
                const y = 3.5 - (t * 6.0); 
                let r;
                if (y > 2.0) r = 0.4 + (3.5 - y) * 0.5;
                else if (y > 0.0) r = 0.8 + (2.0 - y) * 0.6;
                else r = 1.2 + (0.0 - y) * 0.7;
                
                const pattern = levelPatterns[level % levelPatterns.length];
                for(let i = 0; i < pattern.length; i++) {
                    let mIdx = 0;
                    if(pattern[i] === 'blue') mIdx=1; else if(pattern[i] === 'white') mIdx=2; else if(pattern[i] === 'pink') mIdx=3;
                    const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterials[mIdx]);
                    const angle = (i / pattern.length) * Math.PI * 2 + (level * 0.5);
                    ornament.position.set(r * Math.cos(angle), y, r * Math.sin(angle));
                    treeGroup.add(ornament);
                }
            }
        }
        createOrnaments();

        // --- 3. ESTRELLA ---
        function createStar() {
            const starShape = new THREE.Shape();
            const points = 5;
            for(let i = 0; i < points * 2; i++) {
                const r = i % 2 === 0 ? 0.6 : 0.25;
                const a = (i / (points * 2)) * Math.PI * 2;
                const x = Math.cos(a) * r;
                const y = Math.sin(a) * r;
                if(i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
            }
            const geometry = new THREE.ExtrudeGeometry(starShape, { depth: 0.15, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 });
            const material = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xFFaa00, emissiveIntensity: 0.5 });
            const star = new THREE.Mesh(geometry, material);
            const starLight = new THREE.PointLight(0xFFD700, 1.5, 8); 
            star.add(starLight);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprites/glow.png'), 
                color: 0xFFD700, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.7 
            }));
            sprite.scale.set(3, 3, 1);
            star.add(sprite);
            star.rotation.z = Math.PI / 2;
            return star;
        }
        const star = createStar();
        star.position.y = 6.8;
        treeGroup.add(star);

        // --- 4. PART칈CULAS DEL 츼RBOL (LEVANTADAS) ---
        function createTreeParticles() {
            const geom = new THREE.BufferGeometry();
            const pos = [];

            levelsData.forEach((level, index) => {
                const bottomY = level.y - (level.height / 2);
                
                // Determinamos qu칠 tan lejos flotan las part칤culas
                // En la base: 1.1 a 1.4 veces el radio
                // En la punta (index 3): 1.2 a 1.8 veces el radio (m치s volumen para que no se vea apretada)
                let minOffset = 1.1; 
                let rangeOffset = 0.3;

                if (index === 3) { // Si es la punta
                    minOffset = 1.2;
                    rangeOffset = 0.6; // Mucho m치s rango para la punta
                }

                for(let i = 0; i < level.particleCount; i++) {
                    const h = Math.random() * level.height; 
                    const currentY = bottomY + h;
                    const exactSurfaceRadius = level.radius * (1 - (h / level.height));

                    // Multiplicador para "levantar" las part칤culas
                    const levitation = minOffset + Math.random() * rangeOffset;
                    
                    const r = exactSurfaceRadius * levitation;
                    const theta = Math.random() * Math.PI * 2;
                    
                    pos.push(r * Math.cos(theta)); 
                    pos.push(currentY);            
                    pos.push(r * Math.sin(theta)); 
                }
            });
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            
            return new THREE.Points(geom, new THREE.PointsMaterial({
                size: 0.12, 
                color: 0x66ff66,
                transparent: true, 
                opacity: 1.0, 
                map: particleTexture,
                depthWrite: false, 
                blending: THREE.AdditiveBlending 
            }));
        }
        const treeParticles = createTreeParticles();
        treeGroup.add(treeParticles);

        // --- 5. PART칈CULAS TRONCO ---
        function createTrunkParticles() {
            const geom = new THREE.BufferGeometry();
            const pos = [];
            const count = 2500;
            for(let i = 0; i < count; i++) {
                const h = (Math.random() * 1.5) - 4.25;
                const r = 0.5 + Math.random() * 0.4;
                const a = Math.random() * Math.PI * 2;
                pos.push(Math.cos(a)*r, h, Math.sin(a)*r);
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            return new THREE.Points(geom, new THREE.PointsMaterial({
                size: 0.1, color: 0x8B4513, transparent: true, opacity: 0.8,
                map: particleTexture, depthWrite: false, blending: THREE.AdditiveBlending
            }));
        }
        const trunkParticles = createTrunkParticles();
        treeGroup.add(trunkParticles);

        // --- 6. NIEVE ---
        function createSimpleSnow() {
            const count = 1000;
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i = 0; i < count; i++) {
                pos.push((Math.random()-0.5)*30, Math.random()*20, (Math.random()-0.5)*30);
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            return new THREE.Points(geom, new THREE.PointsMaterial({
                size: 0.2, color: 0xffffff, transparent: true, opacity: 0.8,
                map: particleTexture, depthWrite: false, blending: THREE.AdditiveBlending
            }));
        }
        const snow = createSimpleSnow();
        scene.add(snow);

        // --- LUCES ---
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.5); 
        mainLight.position.set(5, 10, 7);
        scene.add(mainLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.2)); 

        // --- INTERACCI칍N ---
        let isDragging = false, prevX = 0, prevY = 0;
        const startDrag = (x, y) => { isDragging = true; prevX = x; prevY = y; };
        const moveDrag = (x, y) => {
            if(isDragging) {
                treeGroup.rotation.y += (x - prevX) * 0.01;
                treeGroup.rotation.x += (y - prevY) * 0.01;
                prevX = x; prevY = y;
            }
        };
        const endDrag = () => { isDragging = false; };

        document.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
        document.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
        document.addEventListener('touchmove', e => moveDrag(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
        document.addEventListener('touchend', endDrag);

        // --- ANIMACI칍N ---
        function animate() {
            requestAnimationFrame(animate);
            if(!isDragging) treeGroup.rotation.y += 0.005;

            const sPos = snow.geometry.attributes.position.array;
            for(let i = 1; i < sPos.length; i += 3) {
                sPos[i] -= 0.05;
                if(sPos[i] < -5) sPos[i] = 15;
            }
            snow.geometry.attributes.position.needsUpdate = true;

            const time = Date.now() * 0.002;
            const pulse = 0.6 + Math.sin(time) * 0.2;
            ornamentMaterials.forEach(m => m.emissiveIntensity = pulse);

            renderer.render(scene, camera);
        }
        animate();

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(window.innerWidth < 768) camera.position.set(0, 1.5, 13);
            else camera.position.set(0, 1, 11);
        }
        window.addEventListener('resize', onResize);
        onResize();
    </script>
</body>
</html>